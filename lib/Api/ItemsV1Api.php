<?php
/**
 * ItemsV1Api
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * FastBound API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.62
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ItemsV1Api Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ItemsV1Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation accountNumApiItemsExternalIdGet
     *
     * Retrieves the specified item by External ID.
     *
     * @param  string $external_id The External ID of the item to retrieve. (required)
     * @param  string $account_num The assigned account number. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetItemCommand
     */
    public function accountNumApiItemsExternalIdGet($external_id, $account_num)
    {
        list($response) = $this->accountNumApiItemsExternalIdGetWithHttpInfo($external_id, $account_num);
        return $response;
    }

    /**
     * Operation accountNumApiItemsExternalIdGetWithHttpInfo
     *
     * Retrieves the specified item by External ID.
     *
     * @param  string $external_id The External ID of the item to retrieve. (required)
     * @param  string $account_num The assigned account number. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetItemCommand, HTTP status code, HTTP response headers (array of strings)
     */
    public function accountNumApiItemsExternalIdGetWithHttpInfo($external_id, $account_num)
    {
        $returnType = '\Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetItemCommand';
        $request = $this->accountNumApiItemsExternalIdGetRequest($external_id, $account_num);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetItemCommand',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation accountNumApiItemsExternalIdGetAsync
     *
     * Retrieves the specified item by External ID.
     *
     * @param  string $external_id The External ID of the item to retrieve. (required)
     * @param  string $account_num The assigned account number. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsExternalIdGetAsync($external_id, $account_num)
    {
        return $this->accountNumApiItemsExternalIdGetAsyncWithHttpInfo($external_id, $account_num)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation accountNumApiItemsExternalIdGetAsyncWithHttpInfo
     *
     * Retrieves the specified item by External ID.
     *
     * @param  string $external_id The External ID of the item to retrieve. (required)
     * @param  string $account_num The assigned account number. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsExternalIdGetAsyncWithHttpInfo($external_id, $account_num)
    {
        $returnType = '\Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetItemCommand';
        $request = $this->accountNumApiItemsExternalIdGetRequest($external_id, $account_num);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'accountNumApiItemsExternalIdGet'
     *
     * @param  string $external_id The External ID of the item to retrieve. (required)
     * @param  string $account_num The assigned account number. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function accountNumApiItemsExternalIdGetRequest($external_id, $account_num)
    {
        // verify the required parameter 'external_id' is set
        if ($external_id === null || (is_array($external_id) && count($external_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $external_id when calling accountNumApiItemsExternalIdGet'
            );
        }
        // verify the required parameter 'account_num' is set
        if ($account_num === null || (is_array($account_num) && count($account_num) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_num when calling accountNumApiItemsExternalIdGet'
            );
        }

        $resourcePath = '/{accountNum}/api/Items/{externalId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($external_id !== null) {
            $resourcePath = str_replace(
                '{' . 'externalId' . '}',
                ObjectSerializer::toPathValue($external_id),
                $resourcePath
            );
        }
        // path params
        if ($account_num !== null) {
            $resourcePath = str_replace(
                '{' . 'accountNum' . '}',
                ObjectSerializer::toPathValue($account_num),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation accountNumApiItemsGet
     *
     * Retrieves the account's items.
     *
     * @param  string $account_num The assigned account number. (required)
     * @param  string $search Optional query parameter to search for items. When set, other search parameters (e.g., serial) are ignored. (optional)
     * @param  string $item_number Optional query parameter to search for a specific item number. Ignored if search is set. (optional)
     * @param  string $serial Optional query parameter to search for a specific serial. Ignored if search is set. (optional)
     * @param  string $manufacturer Optional query parameter to search for a specific manufacturer. Ignored if search is set. (optional)
     * @param  string $importer Optional query parameter to search for a specific importer. Ignored if search is set. (optional)
     * @param  string $model Optional query parameter to search for a specific model. Ignored if search is set. (optional)
     * @param  string[] $type Optional query parameter to search for a specific type. Ignored if search is set. Add multiple to the query string to               search by multiple types (e.g., type&#x3D;Pistol&amp;type&#x3D;Revolver). (optional)
     * @param  string $caliber Optional query parameter to search for a specific caliber. Ignored if search is set. (optional)
     * @param  string $location Optional query parameter to search for a specific location. Ignored if search is set. (optional)
     * @param  string[] $condition Optional query parameter to search for a specific condition. Ignored if search is set. Add multiple to the query              string to search by multiple types (e.g., condition&#x3D;New&amp;condition&#x3D;Used). (optional)
     * @param  string $mpn Optional query parameter to search for a specific MPN. Ignored if search is set. (optional)
     * @param  string $upc Optional query parameter to search for a specific UPC. Ignored if search is set. (optional)
     * @param  string $sku Optional query parameter to search for a specific SKU. Ignored if search is set. (optional)
     * @param  bool $is_theft_loss Optional query parameter to search for items with a disposition type of Theft/Loss. If true,              returns items whose Disposition Type was Theft/Loss. If false, returns items whose Disposition Type was not Theft/Loss. If              not set, does not modify the query. Ignored if search is set. (optional)
     * @param  bool $is_destroyed Optional query parameter to search for items with a disposition type of Destroyed. If true,              returns items whose Disposition Type was Destroyed. If false, returns items whose Disposition Type was not Destroyed. If              not set, does not modify the query. Ignored if search is set. (optional)
     * @param  bool $do_not_dispose Optional query parameter to search for items marked as Do Not Dispose. If true, returns items marked as Do              Not Dispose. If false, returns items not marked as Do Not Dispose. If not set, does not modify the query. Ignored if search is set. (optional)
     * @param  string $disposition_id Optional query parameter to search for a specific disposition. Ignored if search is set. (optional)
     * @param  \Swagger\Client\Model\FastBoundDataEnumsItemStatuses $status Optional query parameter to filter results by status. Valid values are 1 (Available), 2 (Pending Disposal), 3 (Disposed), and 4 (Deleted). (optional)
     * @param  \DateTime $acquired_on_or_after Optional query parameter to return items acquired on or after this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  \DateTime $acquired_on_or_before Optional query parameter to return items acquired on or before this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  string $acquire_purchase_order_number Optional query parameter to search for a specific acquisition purchase order number. Ignored if search is set. (optional)
     * @param  string $acquire_invoice_number Optional query parameter to search for a specific acquisition invoice number. Ignored if search is set. (optional)
     * @param  string $acquire_shipment_tracking_number Optional query parameter to search for a specific acquisition shipment tracking number. Ignored if search is set. (optional)
     * @param  \DateTime $disposed_on_or_after Optional query parameter to return items disposed on or after this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  \DateTime $disposed_on_or_before Optional query parameter to return items disposed on or before this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  string $dispose_purchase_order_number Optional query parameter to search for a specific disposition purchase order number. Ignored if search is set. (optional)
     * @param  string $dispose_invoice_number Optional query parameter to search for a specific disposition invoice number. Ignored if search is set. (optional)
     * @param  string $dispose_shipment_tracking_number Optional query parameter to search for a specific disposition shipment tracking number. Ignored if search is set. (optional)
     * @param  bool $has_external_id Optional query parameter to filter results by presence or absence of an ExternalId. true returns only items with an ExternalId; false returns              only items with no ExternalId. Unset doesn&#x27;t filter by ExternalId at all. (optional)
     * @param  string[] $acquisition_type Optional query parameter to search for a specific acquisition type. Ignored if search is set. Add multiple to the query              string to search by multiple types (e.g., acquisitionType&#x3D;Purchase&amp;acquisitionType&#x3D;Consignment). (optional)
     * @param  int $take Optional query parameter to specify the number of items to return. (optional)
     * @param  int $skip Optional query parameter to specify how many pages to skip. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetAllCommand
     */
    public function accountNumApiItemsGet($account_num, $search = null, $item_number = null, $serial = null, $manufacturer = null, $importer = null, $model = null, $type = null, $caliber = null, $location = null, $condition = null, $mpn = null, $upc = null, $sku = null, $is_theft_loss = null, $is_destroyed = null, $do_not_dispose = null, $disposition_id = null, $status = null, $acquired_on_or_after = null, $acquired_on_or_before = null, $acquire_purchase_order_number = null, $acquire_invoice_number = null, $acquire_shipment_tracking_number = null, $disposed_on_or_after = null, $disposed_on_or_before = null, $dispose_purchase_order_number = null, $dispose_invoice_number = null, $dispose_shipment_tracking_number = null, $has_external_id = null, $acquisition_type = null, $take = null, $skip = null)
    {
        list($response) = $this->accountNumApiItemsGetWithHttpInfo($account_num, $search, $item_number, $serial, $manufacturer, $importer, $model, $type, $caliber, $location, $condition, $mpn, $upc, $sku, $is_theft_loss, $is_destroyed, $do_not_dispose, $disposition_id, $status, $acquired_on_or_after, $acquired_on_or_before, $acquire_purchase_order_number, $acquire_invoice_number, $acquire_shipment_tracking_number, $disposed_on_or_after, $disposed_on_or_before, $dispose_purchase_order_number, $dispose_invoice_number, $dispose_shipment_tracking_number, $has_external_id, $acquisition_type, $take, $skip);
        return $response;
    }

    /**
     * Operation accountNumApiItemsGetWithHttpInfo
     *
     * Retrieves the account's items.
     *
     * @param  string $account_num The assigned account number. (required)
     * @param  string $search Optional query parameter to search for items. When set, other search parameters (e.g., serial) are ignored. (optional)
     * @param  string $item_number Optional query parameter to search for a specific item number. Ignored if search is set. (optional)
     * @param  string $serial Optional query parameter to search for a specific serial. Ignored if search is set. (optional)
     * @param  string $manufacturer Optional query parameter to search for a specific manufacturer. Ignored if search is set. (optional)
     * @param  string $importer Optional query parameter to search for a specific importer. Ignored if search is set. (optional)
     * @param  string $model Optional query parameter to search for a specific model. Ignored if search is set. (optional)
     * @param  string[] $type Optional query parameter to search for a specific type. Ignored if search is set. Add multiple to the query string to               search by multiple types (e.g., type&#x3D;Pistol&amp;type&#x3D;Revolver). (optional)
     * @param  string $caliber Optional query parameter to search for a specific caliber. Ignored if search is set. (optional)
     * @param  string $location Optional query parameter to search for a specific location. Ignored if search is set. (optional)
     * @param  string[] $condition Optional query parameter to search for a specific condition. Ignored if search is set. Add multiple to the query              string to search by multiple types (e.g., condition&#x3D;New&amp;condition&#x3D;Used). (optional)
     * @param  string $mpn Optional query parameter to search for a specific MPN. Ignored if search is set. (optional)
     * @param  string $upc Optional query parameter to search for a specific UPC. Ignored if search is set. (optional)
     * @param  string $sku Optional query parameter to search for a specific SKU. Ignored if search is set. (optional)
     * @param  bool $is_theft_loss Optional query parameter to search for items with a disposition type of Theft/Loss. If true,              returns items whose Disposition Type was Theft/Loss. If false, returns items whose Disposition Type was not Theft/Loss. If              not set, does not modify the query. Ignored if search is set. (optional)
     * @param  bool $is_destroyed Optional query parameter to search for items with a disposition type of Destroyed. If true,              returns items whose Disposition Type was Destroyed. If false, returns items whose Disposition Type was not Destroyed. If              not set, does not modify the query. Ignored if search is set. (optional)
     * @param  bool $do_not_dispose Optional query parameter to search for items marked as Do Not Dispose. If true, returns items marked as Do              Not Dispose. If false, returns items not marked as Do Not Dispose. If not set, does not modify the query. Ignored if search is set. (optional)
     * @param  string $disposition_id Optional query parameter to search for a specific disposition. Ignored if search is set. (optional)
     * @param  \Swagger\Client\Model\FastBoundDataEnumsItemStatuses $status Optional query parameter to filter results by status. Valid values are 1 (Available), 2 (Pending Disposal), 3 (Disposed), and 4 (Deleted). (optional)
     * @param  \DateTime $acquired_on_or_after Optional query parameter to return items acquired on or after this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  \DateTime $acquired_on_or_before Optional query parameter to return items acquired on or before this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  string $acquire_purchase_order_number Optional query parameter to search for a specific acquisition purchase order number. Ignored if search is set. (optional)
     * @param  string $acquire_invoice_number Optional query parameter to search for a specific acquisition invoice number. Ignored if search is set. (optional)
     * @param  string $acquire_shipment_tracking_number Optional query parameter to search for a specific acquisition shipment tracking number. Ignored if search is set. (optional)
     * @param  \DateTime $disposed_on_or_after Optional query parameter to return items disposed on or after this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  \DateTime $disposed_on_or_before Optional query parameter to return items disposed on or before this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  string $dispose_purchase_order_number Optional query parameter to search for a specific disposition purchase order number. Ignored if search is set. (optional)
     * @param  string $dispose_invoice_number Optional query parameter to search for a specific disposition invoice number. Ignored if search is set. (optional)
     * @param  string $dispose_shipment_tracking_number Optional query parameter to search for a specific disposition shipment tracking number. Ignored if search is set. (optional)
     * @param  bool $has_external_id Optional query parameter to filter results by presence or absence of an ExternalId. true returns only items with an ExternalId; false returns              only items with no ExternalId. Unset doesn&#x27;t filter by ExternalId at all. (optional)
     * @param  string[] $acquisition_type Optional query parameter to search for a specific acquisition type. Ignored if search is set. Add multiple to the query              string to search by multiple types (e.g., acquisitionType&#x3D;Purchase&amp;acquisitionType&#x3D;Consignment). (optional)
     * @param  int $take Optional query parameter to specify the number of items to return. (optional)
     * @param  int $skip Optional query parameter to specify how many pages to skip. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetAllCommand, HTTP status code, HTTP response headers (array of strings)
     */
    public function accountNumApiItemsGetWithHttpInfo($account_num, $search = null, $item_number = null, $serial = null, $manufacturer = null, $importer = null, $model = null, $type = null, $caliber = null, $location = null, $condition = null, $mpn = null, $upc = null, $sku = null, $is_theft_loss = null, $is_destroyed = null, $do_not_dispose = null, $disposition_id = null, $status = null, $acquired_on_or_after = null, $acquired_on_or_before = null, $acquire_purchase_order_number = null, $acquire_invoice_number = null, $acquire_shipment_tracking_number = null, $disposed_on_or_after = null, $disposed_on_or_before = null, $dispose_purchase_order_number = null, $dispose_invoice_number = null, $dispose_shipment_tracking_number = null, $has_external_id = null, $acquisition_type = null, $take = null, $skip = null)
    {
        $returnType = '\Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetAllCommand';
        $request = $this->accountNumApiItemsGetRequest($account_num, $search, $item_number, $serial, $manufacturer, $importer, $model, $type, $caliber, $location, $condition, $mpn, $upc, $sku, $is_theft_loss, $is_destroyed, $do_not_dispose, $disposition_id, $status, $acquired_on_or_after, $acquired_on_or_before, $acquire_purchase_order_number, $acquire_invoice_number, $acquire_shipment_tracking_number, $disposed_on_or_after, $disposed_on_or_before, $dispose_purchase_order_number, $dispose_invoice_number, $dispose_shipment_tracking_number, $has_external_id, $acquisition_type, $take, $skip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetAllCommand',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FastBoundWebModelsApiV1ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation accountNumApiItemsGetAsync
     *
     * Retrieves the account's items.
     *
     * @param  string $account_num The assigned account number. (required)
     * @param  string $search Optional query parameter to search for items. When set, other search parameters (e.g., serial) are ignored. (optional)
     * @param  string $item_number Optional query parameter to search for a specific item number. Ignored if search is set. (optional)
     * @param  string $serial Optional query parameter to search for a specific serial. Ignored if search is set. (optional)
     * @param  string $manufacturer Optional query parameter to search for a specific manufacturer. Ignored if search is set. (optional)
     * @param  string $importer Optional query parameter to search for a specific importer. Ignored if search is set. (optional)
     * @param  string $model Optional query parameter to search for a specific model. Ignored if search is set. (optional)
     * @param  string[] $type Optional query parameter to search for a specific type. Ignored if search is set. Add multiple to the query string to               search by multiple types (e.g., type&#x3D;Pistol&amp;type&#x3D;Revolver). (optional)
     * @param  string $caliber Optional query parameter to search for a specific caliber. Ignored if search is set. (optional)
     * @param  string $location Optional query parameter to search for a specific location. Ignored if search is set. (optional)
     * @param  string[] $condition Optional query parameter to search for a specific condition. Ignored if search is set. Add multiple to the query              string to search by multiple types (e.g., condition&#x3D;New&amp;condition&#x3D;Used). (optional)
     * @param  string $mpn Optional query parameter to search for a specific MPN. Ignored if search is set. (optional)
     * @param  string $upc Optional query parameter to search for a specific UPC. Ignored if search is set. (optional)
     * @param  string $sku Optional query parameter to search for a specific SKU. Ignored if search is set. (optional)
     * @param  bool $is_theft_loss Optional query parameter to search for items with a disposition type of Theft/Loss. If true,              returns items whose Disposition Type was Theft/Loss. If false, returns items whose Disposition Type was not Theft/Loss. If              not set, does not modify the query. Ignored if search is set. (optional)
     * @param  bool $is_destroyed Optional query parameter to search for items with a disposition type of Destroyed. If true,              returns items whose Disposition Type was Destroyed. If false, returns items whose Disposition Type was not Destroyed. If              not set, does not modify the query. Ignored if search is set. (optional)
     * @param  bool $do_not_dispose Optional query parameter to search for items marked as Do Not Dispose. If true, returns items marked as Do              Not Dispose. If false, returns items not marked as Do Not Dispose. If not set, does not modify the query. Ignored if search is set. (optional)
     * @param  string $disposition_id Optional query parameter to search for a specific disposition. Ignored if search is set. (optional)
     * @param  \Swagger\Client\Model\FastBoundDataEnumsItemStatuses $status Optional query parameter to filter results by status. Valid values are 1 (Available), 2 (Pending Disposal), 3 (Disposed), and 4 (Deleted). (optional)
     * @param  \DateTime $acquired_on_or_after Optional query parameter to return items acquired on or after this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  \DateTime $acquired_on_or_before Optional query parameter to return items acquired on or before this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  string $acquire_purchase_order_number Optional query parameter to search for a specific acquisition purchase order number. Ignored if search is set. (optional)
     * @param  string $acquire_invoice_number Optional query parameter to search for a specific acquisition invoice number. Ignored if search is set. (optional)
     * @param  string $acquire_shipment_tracking_number Optional query parameter to search for a specific acquisition shipment tracking number. Ignored if search is set. (optional)
     * @param  \DateTime $disposed_on_or_after Optional query parameter to return items disposed on or after this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  \DateTime $disposed_on_or_before Optional query parameter to return items disposed on or before this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  string $dispose_purchase_order_number Optional query parameter to search for a specific disposition purchase order number. Ignored if search is set. (optional)
     * @param  string $dispose_invoice_number Optional query parameter to search for a specific disposition invoice number. Ignored if search is set. (optional)
     * @param  string $dispose_shipment_tracking_number Optional query parameter to search for a specific disposition shipment tracking number. Ignored if search is set. (optional)
     * @param  bool $has_external_id Optional query parameter to filter results by presence or absence of an ExternalId. true returns only items with an ExternalId; false returns              only items with no ExternalId. Unset doesn&#x27;t filter by ExternalId at all. (optional)
     * @param  string[] $acquisition_type Optional query parameter to search for a specific acquisition type. Ignored if search is set. Add multiple to the query              string to search by multiple types (e.g., acquisitionType&#x3D;Purchase&amp;acquisitionType&#x3D;Consignment). (optional)
     * @param  int $take Optional query parameter to specify the number of items to return. (optional)
     * @param  int $skip Optional query parameter to specify how many pages to skip. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsGetAsync($account_num, $search = null, $item_number = null, $serial = null, $manufacturer = null, $importer = null, $model = null, $type = null, $caliber = null, $location = null, $condition = null, $mpn = null, $upc = null, $sku = null, $is_theft_loss = null, $is_destroyed = null, $do_not_dispose = null, $disposition_id = null, $status = null, $acquired_on_or_after = null, $acquired_on_or_before = null, $acquire_purchase_order_number = null, $acquire_invoice_number = null, $acquire_shipment_tracking_number = null, $disposed_on_or_after = null, $disposed_on_or_before = null, $dispose_purchase_order_number = null, $dispose_invoice_number = null, $dispose_shipment_tracking_number = null, $has_external_id = null, $acquisition_type = null, $take = null, $skip = null)
    {
        return $this->accountNumApiItemsGetAsyncWithHttpInfo($account_num, $search, $item_number, $serial, $manufacturer, $importer, $model, $type, $caliber, $location, $condition, $mpn, $upc, $sku, $is_theft_loss, $is_destroyed, $do_not_dispose, $disposition_id, $status, $acquired_on_or_after, $acquired_on_or_before, $acquire_purchase_order_number, $acquire_invoice_number, $acquire_shipment_tracking_number, $disposed_on_or_after, $disposed_on_or_before, $dispose_purchase_order_number, $dispose_invoice_number, $dispose_shipment_tracking_number, $has_external_id, $acquisition_type, $take, $skip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation accountNumApiItemsGetAsyncWithHttpInfo
     *
     * Retrieves the account's items.
     *
     * @param  string $account_num The assigned account number. (required)
     * @param  string $search Optional query parameter to search for items. When set, other search parameters (e.g., serial) are ignored. (optional)
     * @param  string $item_number Optional query parameter to search for a specific item number. Ignored if search is set. (optional)
     * @param  string $serial Optional query parameter to search for a specific serial. Ignored if search is set. (optional)
     * @param  string $manufacturer Optional query parameter to search for a specific manufacturer. Ignored if search is set. (optional)
     * @param  string $importer Optional query parameter to search for a specific importer. Ignored if search is set. (optional)
     * @param  string $model Optional query parameter to search for a specific model. Ignored if search is set. (optional)
     * @param  string[] $type Optional query parameter to search for a specific type. Ignored if search is set. Add multiple to the query string to               search by multiple types (e.g., type&#x3D;Pistol&amp;type&#x3D;Revolver). (optional)
     * @param  string $caliber Optional query parameter to search for a specific caliber. Ignored if search is set. (optional)
     * @param  string $location Optional query parameter to search for a specific location. Ignored if search is set. (optional)
     * @param  string[] $condition Optional query parameter to search for a specific condition. Ignored if search is set. Add multiple to the query              string to search by multiple types (e.g., condition&#x3D;New&amp;condition&#x3D;Used). (optional)
     * @param  string $mpn Optional query parameter to search for a specific MPN. Ignored if search is set. (optional)
     * @param  string $upc Optional query parameter to search for a specific UPC. Ignored if search is set. (optional)
     * @param  string $sku Optional query parameter to search for a specific SKU. Ignored if search is set. (optional)
     * @param  bool $is_theft_loss Optional query parameter to search for items with a disposition type of Theft/Loss. If true,              returns items whose Disposition Type was Theft/Loss. If false, returns items whose Disposition Type was not Theft/Loss. If              not set, does not modify the query. Ignored if search is set. (optional)
     * @param  bool $is_destroyed Optional query parameter to search for items with a disposition type of Destroyed. If true,              returns items whose Disposition Type was Destroyed. If false, returns items whose Disposition Type was not Destroyed. If              not set, does not modify the query. Ignored if search is set. (optional)
     * @param  bool $do_not_dispose Optional query parameter to search for items marked as Do Not Dispose. If true, returns items marked as Do              Not Dispose. If false, returns items not marked as Do Not Dispose. If not set, does not modify the query. Ignored if search is set. (optional)
     * @param  string $disposition_id Optional query parameter to search for a specific disposition. Ignored if search is set. (optional)
     * @param  \Swagger\Client\Model\FastBoundDataEnumsItemStatuses $status Optional query parameter to filter results by status. Valid values are 1 (Available), 2 (Pending Disposal), 3 (Disposed), and 4 (Deleted). (optional)
     * @param  \DateTime $acquired_on_or_after Optional query parameter to return items acquired on or after this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  \DateTime $acquired_on_or_before Optional query parameter to return items acquired on or before this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  string $acquire_purchase_order_number Optional query parameter to search for a specific acquisition purchase order number. Ignored if search is set. (optional)
     * @param  string $acquire_invoice_number Optional query parameter to search for a specific acquisition invoice number. Ignored if search is set. (optional)
     * @param  string $acquire_shipment_tracking_number Optional query parameter to search for a specific acquisition shipment tracking number. Ignored if search is set. (optional)
     * @param  \DateTime $disposed_on_or_after Optional query parameter to return items disposed on or after this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  \DateTime $disposed_on_or_before Optional query parameter to return items disposed on or before this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  string $dispose_purchase_order_number Optional query parameter to search for a specific disposition purchase order number. Ignored if search is set. (optional)
     * @param  string $dispose_invoice_number Optional query parameter to search for a specific disposition invoice number. Ignored if search is set. (optional)
     * @param  string $dispose_shipment_tracking_number Optional query parameter to search for a specific disposition shipment tracking number. Ignored if search is set. (optional)
     * @param  bool $has_external_id Optional query parameter to filter results by presence or absence of an ExternalId. true returns only items with an ExternalId; false returns              only items with no ExternalId. Unset doesn&#x27;t filter by ExternalId at all. (optional)
     * @param  string[] $acquisition_type Optional query parameter to search for a specific acquisition type. Ignored if search is set. Add multiple to the query              string to search by multiple types (e.g., acquisitionType&#x3D;Purchase&amp;acquisitionType&#x3D;Consignment). (optional)
     * @param  int $take Optional query parameter to specify the number of items to return. (optional)
     * @param  int $skip Optional query parameter to specify how many pages to skip. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsGetAsyncWithHttpInfo($account_num, $search = null, $item_number = null, $serial = null, $manufacturer = null, $importer = null, $model = null, $type = null, $caliber = null, $location = null, $condition = null, $mpn = null, $upc = null, $sku = null, $is_theft_loss = null, $is_destroyed = null, $do_not_dispose = null, $disposition_id = null, $status = null, $acquired_on_or_after = null, $acquired_on_or_before = null, $acquire_purchase_order_number = null, $acquire_invoice_number = null, $acquire_shipment_tracking_number = null, $disposed_on_or_after = null, $disposed_on_or_before = null, $dispose_purchase_order_number = null, $dispose_invoice_number = null, $dispose_shipment_tracking_number = null, $has_external_id = null, $acquisition_type = null, $take = null, $skip = null)
    {
        $returnType = '\Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetAllCommand';
        $request = $this->accountNumApiItemsGetRequest($account_num, $search, $item_number, $serial, $manufacturer, $importer, $model, $type, $caliber, $location, $condition, $mpn, $upc, $sku, $is_theft_loss, $is_destroyed, $do_not_dispose, $disposition_id, $status, $acquired_on_or_after, $acquired_on_or_before, $acquire_purchase_order_number, $acquire_invoice_number, $acquire_shipment_tracking_number, $disposed_on_or_after, $disposed_on_or_before, $dispose_purchase_order_number, $dispose_invoice_number, $dispose_shipment_tracking_number, $has_external_id, $acquisition_type, $take, $skip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'accountNumApiItemsGet'
     *
     * @param  string $account_num The assigned account number. (required)
     * @param  string $search Optional query parameter to search for items. When set, other search parameters (e.g., serial) are ignored. (optional)
     * @param  string $item_number Optional query parameter to search for a specific item number. Ignored if search is set. (optional)
     * @param  string $serial Optional query parameter to search for a specific serial. Ignored if search is set. (optional)
     * @param  string $manufacturer Optional query parameter to search for a specific manufacturer. Ignored if search is set. (optional)
     * @param  string $importer Optional query parameter to search for a specific importer. Ignored if search is set. (optional)
     * @param  string $model Optional query parameter to search for a specific model. Ignored if search is set. (optional)
     * @param  string[] $type Optional query parameter to search for a specific type. Ignored if search is set. Add multiple to the query string to               search by multiple types (e.g., type&#x3D;Pistol&amp;type&#x3D;Revolver). (optional)
     * @param  string $caliber Optional query parameter to search for a specific caliber. Ignored if search is set. (optional)
     * @param  string $location Optional query parameter to search for a specific location. Ignored if search is set. (optional)
     * @param  string[] $condition Optional query parameter to search for a specific condition. Ignored if search is set. Add multiple to the query              string to search by multiple types (e.g., condition&#x3D;New&amp;condition&#x3D;Used). (optional)
     * @param  string $mpn Optional query parameter to search for a specific MPN. Ignored if search is set. (optional)
     * @param  string $upc Optional query parameter to search for a specific UPC. Ignored if search is set. (optional)
     * @param  string $sku Optional query parameter to search for a specific SKU. Ignored if search is set. (optional)
     * @param  bool $is_theft_loss Optional query parameter to search for items with a disposition type of Theft/Loss. If true,              returns items whose Disposition Type was Theft/Loss. If false, returns items whose Disposition Type was not Theft/Loss. If              not set, does not modify the query. Ignored if search is set. (optional)
     * @param  bool $is_destroyed Optional query parameter to search for items with a disposition type of Destroyed. If true,              returns items whose Disposition Type was Destroyed. If false, returns items whose Disposition Type was not Destroyed. If              not set, does not modify the query. Ignored if search is set. (optional)
     * @param  bool $do_not_dispose Optional query parameter to search for items marked as Do Not Dispose. If true, returns items marked as Do              Not Dispose. If false, returns items not marked as Do Not Dispose. If not set, does not modify the query. Ignored if search is set. (optional)
     * @param  string $disposition_id Optional query parameter to search for a specific disposition. Ignored if search is set. (optional)
     * @param  \Swagger\Client\Model\FastBoundDataEnumsItemStatuses $status Optional query parameter to filter results by status. Valid values are 1 (Available), 2 (Pending Disposal), 3 (Disposed), and 4 (Deleted). (optional)
     * @param  \DateTime $acquired_on_or_after Optional query parameter to return items acquired on or after this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  \DateTime $acquired_on_or_before Optional query parameter to return items acquired on or before this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  string $acquire_purchase_order_number Optional query parameter to search for a specific acquisition purchase order number. Ignored if search is set. (optional)
     * @param  string $acquire_invoice_number Optional query parameter to search for a specific acquisition invoice number. Ignored if search is set. (optional)
     * @param  string $acquire_shipment_tracking_number Optional query parameter to search for a specific acquisition shipment tracking number. Ignored if search is set. (optional)
     * @param  \DateTime $disposed_on_or_after Optional query parameter to return items disposed on or after this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  \DateTime $disposed_on_or_before Optional query parameter to return items disposed on or before this date in the account&#x27;s time zone. Ignored if search is set. (optional)
     * @param  string $dispose_purchase_order_number Optional query parameter to search for a specific disposition purchase order number. Ignored if search is set. (optional)
     * @param  string $dispose_invoice_number Optional query parameter to search for a specific disposition invoice number. Ignored if search is set. (optional)
     * @param  string $dispose_shipment_tracking_number Optional query parameter to search for a specific disposition shipment tracking number. Ignored if search is set. (optional)
     * @param  bool $has_external_id Optional query parameter to filter results by presence or absence of an ExternalId. true returns only items with an ExternalId; false returns              only items with no ExternalId. Unset doesn&#x27;t filter by ExternalId at all. (optional)
     * @param  string[] $acquisition_type Optional query parameter to search for a specific acquisition type. Ignored if search is set. Add multiple to the query              string to search by multiple types (e.g., acquisitionType&#x3D;Purchase&amp;acquisitionType&#x3D;Consignment). (optional)
     * @param  int $take Optional query parameter to specify the number of items to return. (optional)
     * @param  int $skip Optional query parameter to specify how many pages to skip. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function accountNumApiItemsGetRequest($account_num, $search = null, $item_number = null, $serial = null, $manufacturer = null, $importer = null, $model = null, $type = null, $caliber = null, $location = null, $condition = null, $mpn = null, $upc = null, $sku = null, $is_theft_loss = null, $is_destroyed = null, $do_not_dispose = null, $disposition_id = null, $status = null, $acquired_on_or_after = null, $acquired_on_or_before = null, $acquire_purchase_order_number = null, $acquire_invoice_number = null, $acquire_shipment_tracking_number = null, $disposed_on_or_after = null, $disposed_on_or_before = null, $dispose_purchase_order_number = null, $dispose_invoice_number = null, $dispose_shipment_tracking_number = null, $has_external_id = null, $acquisition_type = null, $take = null, $skip = null)
    {
        // verify the required parameter 'account_num' is set
        if ($account_num === null || (is_array($account_num) && count($account_num) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_num when calling accountNumApiItemsGet'
            );
        }

        $resourcePath = '/{accountNum}/api/Items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search, null);
        }
        // query params
        if ($item_number !== null) {
            $queryParams['itemNumber'] = ObjectSerializer::toQueryValue($item_number, null);
        }
        // query params
        if ($serial !== null) {
            $queryParams['serial'] = ObjectSerializer::toQueryValue($serial, null);
        }
        // query params
        if ($manufacturer !== null) {
            $queryParams['manufacturer'] = ObjectSerializer::toQueryValue($manufacturer, null);
        }
        // query params
        if ($importer !== null) {
            $queryParams['importer'] = ObjectSerializer::toQueryValue($importer, null);
        }
        // query params
        if ($model !== null) {
            $queryParams['model'] = ObjectSerializer::toQueryValue($model, null);
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, 'multi', true);
        }
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($caliber !== null) {
            $queryParams['caliber'] = ObjectSerializer::toQueryValue($caliber, null);
        }
        // query params
        if ($location !== null) {
            $queryParams['location'] = ObjectSerializer::toQueryValue($location, null);
        }
        // query params
        if (is_array($condition)) {
            $condition = ObjectSerializer::serializeCollection($condition, 'multi', true);
        }
        if ($condition !== null) {
            $queryParams['condition'] = ObjectSerializer::toQueryValue($condition, null);
        }
        // query params
        if ($mpn !== null) {
            $queryParams['mpn'] = ObjectSerializer::toQueryValue($mpn, null);
        }
        // query params
        if ($upc !== null) {
            $queryParams['upc'] = ObjectSerializer::toQueryValue($upc, null);
        }
        // query params
        if ($sku !== null) {
            $queryParams['sku'] = ObjectSerializer::toQueryValue($sku, null);
        }
        // query params
        if ($is_theft_loss !== null) {
            $queryParams['isTheftLoss'] = ObjectSerializer::toQueryValue($is_theft_loss, null);
        }
        // query params
        if ($is_destroyed !== null) {
            $queryParams['isDestroyed'] = ObjectSerializer::toQueryValue($is_destroyed, null);
        }
        // query params
        if ($do_not_dispose !== null) {
            $queryParams['doNotDispose'] = ObjectSerializer::toQueryValue($do_not_dispose, null);
        }
        // query params
        if ($disposition_id !== null) {
            $queryParams['dispositionId'] = ObjectSerializer::toQueryValue($disposition_id, 'uuid');
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status, null);
        }
        // query params
        if ($acquired_on_or_after !== null) {
            $queryParams['acquiredOnOrAfter'] = ObjectSerializer::toQueryValue($acquired_on_or_after, 'date-time');
        }
        // query params
        if ($acquired_on_or_before !== null) {
            $queryParams['acquiredOnOrBefore'] = ObjectSerializer::toQueryValue($acquired_on_or_before, 'date-time');
        }
        // query params
        if ($acquire_purchase_order_number !== null) {
            $queryParams['acquirePurchaseOrderNumber'] = ObjectSerializer::toQueryValue($acquire_purchase_order_number, null);
        }
        // query params
        if ($acquire_invoice_number !== null) {
            $queryParams['acquireInvoiceNumber'] = ObjectSerializer::toQueryValue($acquire_invoice_number, null);
        }
        // query params
        if ($acquire_shipment_tracking_number !== null) {
            $queryParams['acquireShipmentTrackingNumber'] = ObjectSerializer::toQueryValue($acquire_shipment_tracking_number, null);
        }
        // query params
        if ($disposed_on_or_after !== null) {
            $queryParams['disposedOnOrAfter'] = ObjectSerializer::toQueryValue($disposed_on_or_after, 'date-time');
        }
        // query params
        if ($disposed_on_or_before !== null) {
            $queryParams['disposedOnOrBefore'] = ObjectSerializer::toQueryValue($disposed_on_or_before, 'date-time');
        }
        // query params
        if ($dispose_purchase_order_number !== null) {
            $queryParams['disposePurchaseOrderNumber'] = ObjectSerializer::toQueryValue($dispose_purchase_order_number, null);
        }
        // query params
        if ($dispose_invoice_number !== null) {
            $queryParams['disposeInvoiceNumber'] = ObjectSerializer::toQueryValue($dispose_invoice_number, null);
        }
        // query params
        if ($dispose_shipment_tracking_number !== null) {
            $queryParams['disposeShipmentTrackingNumber'] = ObjectSerializer::toQueryValue($dispose_shipment_tracking_number, null);
        }
        // query params
        if ($has_external_id !== null) {
            $queryParams['hasExternalId'] = ObjectSerializer::toQueryValue($has_external_id, null);
        }
        // query params
        if (is_array($acquisition_type)) {
            $acquisition_type = ObjectSerializer::serializeCollection($acquisition_type, 'multi', true);
        }
        if ($acquisition_type !== null) {
            $queryParams['acquisitionType'] = ObjectSerializer::toQueryValue($acquisition_type, null);
        }
        // query params
        if ($take !== null) {
            $queryParams['take'] = ObjectSerializer::toQueryValue($take, 'int32');
        }
        // query params
        if ($skip !== null) {
            $queryParams['skip'] = ObjectSerializer::toQueryValue($skip, 'int32');
        }

        // path params
        if ($account_num !== null) {
            $resourcePath = str_replace(
                '{' . 'accountNum' . '}',
                ObjectSerializer::toPathValue($account_num),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation accountNumApiItemsGetByExternalIdExternalIdGet
     *
     * Retrieves the specified item by External ID.
     *
     * @param  string $external_id The External ID of the item to retrieve. (required)
     * @param  string $account_num The assigned account number. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetItemCommand
     */
    public function accountNumApiItemsGetByExternalIdExternalIdGet($external_id, $account_num)
    {
        list($response) = $this->accountNumApiItemsGetByExternalIdExternalIdGetWithHttpInfo($external_id, $account_num);
        return $response;
    }

    /**
     * Operation accountNumApiItemsGetByExternalIdExternalIdGetWithHttpInfo
     *
     * Retrieves the specified item by External ID.
     *
     * @param  string $external_id The External ID of the item to retrieve. (required)
     * @param  string $account_num The assigned account number. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetItemCommand, HTTP status code, HTTP response headers (array of strings)
     */
    public function accountNumApiItemsGetByExternalIdExternalIdGetWithHttpInfo($external_id, $account_num)
    {
        $returnType = '\Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetItemCommand';
        $request = $this->accountNumApiItemsGetByExternalIdExternalIdGetRequest($external_id, $account_num);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetItemCommand',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation accountNumApiItemsGetByExternalIdExternalIdGetAsync
     *
     * Retrieves the specified item by External ID.
     *
     * @param  string $external_id The External ID of the item to retrieve. (required)
     * @param  string $account_num The assigned account number. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsGetByExternalIdExternalIdGetAsync($external_id, $account_num)
    {
        return $this->accountNumApiItemsGetByExternalIdExternalIdGetAsyncWithHttpInfo($external_id, $account_num)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation accountNumApiItemsGetByExternalIdExternalIdGetAsyncWithHttpInfo
     *
     * Retrieves the specified item by External ID.
     *
     * @param  string $external_id The External ID of the item to retrieve. (required)
     * @param  string $account_num The assigned account number. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsGetByExternalIdExternalIdGetAsyncWithHttpInfo($external_id, $account_num)
    {
        $returnType = '\Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetItemCommand';
        $request = $this->accountNumApiItemsGetByExternalIdExternalIdGetRequest($external_id, $account_num);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'accountNumApiItemsGetByExternalIdExternalIdGet'
     *
     * @param  string $external_id The External ID of the item to retrieve. (required)
     * @param  string $account_num The assigned account number. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function accountNumApiItemsGetByExternalIdExternalIdGetRequest($external_id, $account_num)
    {
        // verify the required parameter 'external_id' is set
        if ($external_id === null || (is_array($external_id) && count($external_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $external_id when calling accountNumApiItemsGetByExternalIdExternalIdGet'
            );
        }
        // verify the required parameter 'account_num' is set
        if ($account_num === null || (is_array($account_num) && count($account_num) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_num when calling accountNumApiItemsGetByExternalIdExternalIdGet'
            );
        }

        $resourcePath = '/{accountNum}/api/Items/GetByExternalId/{externalId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($external_id !== null) {
            $resourcePath = str_replace(
                '{' . 'externalId' . '}',
                ObjectSerializer::toPathValue($external_id),
                $resourcePath
            );
        }
        // path params
        if ($account_num !== null) {
            $resourcePath = str_replace(
                '{' . 'accountNum' . '}',
                ObjectSerializer::toPathValue($account_num),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation accountNumApiItemsIdAcquisitionContactContactIdPut
     *
     * Change an item's acquisition contact.
     *
     * @param  string $id The ID of the item on which to change the acquisition contact. (required)
     * @param  string $contact_id The ID of the contact to use as the item&#x27;s acquisition contact. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function accountNumApiItemsIdAcquisitionContactContactIdPut($id, $contact_id, $account_num, $x_audit_user)
    {
        $this->accountNumApiItemsIdAcquisitionContactContactIdPutWithHttpInfo($id, $contact_id, $account_num, $x_audit_user);
    }

    /**
     * Operation accountNumApiItemsIdAcquisitionContactContactIdPutWithHttpInfo
     *
     * Change an item's acquisition contact.
     *
     * @param  string $id The ID of the item on which to change the acquisition contact. (required)
     * @param  string $contact_id The ID of the contact to use as the item&#x27;s acquisition contact. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function accountNumApiItemsIdAcquisitionContactContactIdPutWithHttpInfo($id, $contact_id, $account_num, $x_audit_user)
    {
        $returnType = '';
        $request = $this->accountNumApiItemsIdAcquisitionContactContactIdPutRequest($id, $contact_id, $account_num, $x_audit_user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FastBoundWebModelsApiV1ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation accountNumApiItemsIdAcquisitionContactContactIdPutAsync
     *
     * Change an item's acquisition contact.
     *
     * @param  string $id The ID of the item on which to change the acquisition contact. (required)
     * @param  string $contact_id The ID of the contact to use as the item&#x27;s acquisition contact. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsIdAcquisitionContactContactIdPutAsync($id, $contact_id, $account_num, $x_audit_user)
    {
        return $this->accountNumApiItemsIdAcquisitionContactContactIdPutAsyncWithHttpInfo($id, $contact_id, $account_num, $x_audit_user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation accountNumApiItemsIdAcquisitionContactContactIdPutAsyncWithHttpInfo
     *
     * Change an item's acquisition contact.
     *
     * @param  string $id The ID of the item on which to change the acquisition contact. (required)
     * @param  string $contact_id The ID of the contact to use as the item&#x27;s acquisition contact. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsIdAcquisitionContactContactIdPutAsyncWithHttpInfo($id, $contact_id, $account_num, $x_audit_user)
    {
        $returnType = '';
        $request = $this->accountNumApiItemsIdAcquisitionContactContactIdPutRequest($id, $contact_id, $account_num, $x_audit_user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'accountNumApiItemsIdAcquisitionContactContactIdPut'
     *
     * @param  string $id The ID of the item on which to change the acquisition contact. (required)
     * @param  string $contact_id The ID of the contact to use as the item&#x27;s acquisition contact. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function accountNumApiItemsIdAcquisitionContactContactIdPutRequest($id, $contact_id, $account_num, $x_audit_user)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling accountNumApiItemsIdAcquisitionContactContactIdPut'
            );
        }
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling accountNumApiItemsIdAcquisitionContactContactIdPut'
            );
        }
        // verify the required parameter 'account_num' is set
        if ($account_num === null || (is_array($account_num) && count($account_num) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_num when calling accountNumApiItemsIdAcquisitionContactContactIdPut'
            );
        }
        // verify the required parameter 'x_audit_user' is set
        if ($x_audit_user === null || (is_array($x_audit_user) && count($x_audit_user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_audit_user when calling accountNumApiItemsIdAcquisitionContactContactIdPut'
            );
        }

        $resourcePath = '/{accountNum}/api/Items/{id}/AcquisitionContact/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_audit_user !== null) {
            $headerParams['X-AuditUser'] = ObjectSerializer::toHeaderValue($x_audit_user);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($account_num !== null) {
            $resourcePath = str_replace(
                '{' . 'accountNum' . '}',
                ObjectSerializer::toPathValue($account_num),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation accountNumApiItemsIdDelete
     *
     * Deletes the specified item.
     *
     * @param  string $id The ID of the item to delete. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function accountNumApiItemsIdDelete($id, $account_num, $x_audit_user)
    {
        $this->accountNumApiItemsIdDeleteWithHttpInfo($id, $account_num, $x_audit_user);
    }

    /**
     * Operation accountNumApiItemsIdDeleteWithHttpInfo
     *
     * Deletes the specified item.
     *
     * @param  string $id The ID of the item to delete. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function accountNumApiItemsIdDeleteWithHttpInfo($id, $account_num, $x_audit_user)
    {
        $returnType = '';
        $request = $this->accountNumApiItemsIdDeleteRequest($id, $account_num, $x_audit_user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FastBoundWebModelsApiV1ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation accountNumApiItemsIdDeleteAsync
     *
     * Deletes the specified item.
     *
     * @param  string $id The ID of the item to delete. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsIdDeleteAsync($id, $account_num, $x_audit_user)
    {
        return $this->accountNumApiItemsIdDeleteAsyncWithHttpInfo($id, $account_num, $x_audit_user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation accountNumApiItemsIdDeleteAsyncWithHttpInfo
     *
     * Deletes the specified item.
     *
     * @param  string $id The ID of the item to delete. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsIdDeleteAsyncWithHttpInfo($id, $account_num, $x_audit_user)
    {
        $returnType = '';
        $request = $this->accountNumApiItemsIdDeleteRequest($id, $account_num, $x_audit_user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'accountNumApiItemsIdDelete'
     *
     * @param  string $id The ID of the item to delete. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function accountNumApiItemsIdDeleteRequest($id, $account_num, $x_audit_user)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling accountNumApiItemsIdDelete'
            );
        }
        // verify the required parameter 'account_num' is set
        if ($account_num === null || (is_array($account_num) && count($account_num) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_num when calling accountNumApiItemsIdDelete'
            );
        }
        // verify the required parameter 'x_audit_user' is set
        if ($x_audit_user === null || (is_array($x_audit_user) && count($x_audit_user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_audit_user when calling accountNumApiItemsIdDelete'
            );
        }

        $resourcePath = '/{accountNum}/api/Items/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_audit_user !== null) {
            $headerParams['X-AuditUser'] = ObjectSerializer::toHeaderValue($x_audit_user);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($account_num !== null) {
            $resourcePath = str_replace(
                '{' . 'accountNum' . '}',
                ObjectSerializer::toPathValue($account_num),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation accountNumApiItemsIdGet
     *
     * Retrieves the specified item by unique ID.
     *
     * @param  string $id The ID of the item to retrieve. (required)
     * @param  string $account_num The assigned account number. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetItemCommand
     */
    public function accountNumApiItemsIdGet($id, $account_num)
    {
        list($response) = $this->accountNumApiItemsIdGetWithHttpInfo($id, $account_num);
        return $response;
    }

    /**
     * Operation accountNumApiItemsIdGetWithHttpInfo
     *
     * Retrieves the specified item by unique ID.
     *
     * @param  string $id The ID of the item to retrieve. (required)
     * @param  string $account_num The assigned account number. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetItemCommand, HTTP status code, HTTP response headers (array of strings)
     */
    public function accountNumApiItemsIdGetWithHttpInfo($id, $account_num)
    {
        $returnType = '\Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetItemCommand';
        $request = $this->accountNumApiItemsIdGetRequest($id, $account_num);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetItemCommand',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation accountNumApiItemsIdGetAsync
     *
     * Retrieves the specified item by unique ID.
     *
     * @param  string $id The ID of the item to retrieve. (required)
     * @param  string $account_num The assigned account number. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsIdGetAsync($id, $account_num)
    {
        return $this->accountNumApiItemsIdGetAsyncWithHttpInfo($id, $account_num)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation accountNumApiItemsIdGetAsyncWithHttpInfo
     *
     * Retrieves the specified item by unique ID.
     *
     * @param  string $id The ID of the item to retrieve. (required)
     * @param  string $account_num The assigned account number. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsIdGetAsyncWithHttpInfo($id, $account_num)
    {
        $returnType = '\Swagger\Client\Model\FastBoundWebModelsApiV1ItemsGetItemCommand';
        $request = $this->accountNumApiItemsIdGetRequest($id, $account_num);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'accountNumApiItemsIdGet'
     *
     * @param  string $id The ID of the item to retrieve. (required)
     * @param  string $account_num The assigned account number. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function accountNumApiItemsIdGetRequest($id, $account_num)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling accountNumApiItemsIdGet'
            );
        }
        // verify the required parameter 'account_num' is set
        if ($account_num === null || (is_array($account_num) && count($account_num) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_num when calling accountNumApiItemsIdGet'
            );
        }

        $resourcePath = '/{accountNum}/api/Items/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($account_num !== null) {
            $resourcePath = str_replace(
                '{' . 'accountNum' . '}',
                ObjectSerializer::toPathValue($account_num),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation accountNumApiItemsIdPut
     *
     * Edits the specified item.
     *
     * @param  string $id The ID of the item to edit. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function accountNumApiItemsIdPut($id, $account_num, $x_audit_user)
    {
        $this->accountNumApiItemsIdPutWithHttpInfo($id, $account_num, $x_audit_user);
    }

    /**
     * Operation accountNumApiItemsIdPutWithHttpInfo
     *
     * Edits the specified item.
     *
     * @param  string $id The ID of the item to edit. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function accountNumApiItemsIdPutWithHttpInfo($id, $account_num, $x_audit_user)
    {
        $returnType = '';
        $request = $this->accountNumApiItemsIdPutRequest($id, $account_num, $x_audit_user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FastBoundWebModelsApiV1ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation accountNumApiItemsIdPutAsync
     *
     * Edits the specified item.
     *
     * @param  string $id The ID of the item to edit. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsIdPutAsync($id, $account_num, $x_audit_user)
    {
        return $this->accountNumApiItemsIdPutAsyncWithHttpInfo($id, $account_num, $x_audit_user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation accountNumApiItemsIdPutAsyncWithHttpInfo
     *
     * Edits the specified item.
     *
     * @param  string $id The ID of the item to edit. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsIdPutAsyncWithHttpInfo($id, $account_num, $x_audit_user)
    {
        $returnType = '';
        $request = $this->accountNumApiItemsIdPutRequest($id, $account_num, $x_audit_user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'accountNumApiItemsIdPut'
     *
     * @param  string $id The ID of the item to edit. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function accountNumApiItemsIdPutRequest($id, $account_num, $x_audit_user)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling accountNumApiItemsIdPut'
            );
        }
        // verify the required parameter 'account_num' is set
        if ($account_num === null || (is_array($account_num) && count($account_num) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_num when calling accountNumApiItemsIdPut'
            );
        }
        // verify the required parameter 'x_audit_user' is set
        if ($x_audit_user === null || (is_array($x_audit_user) && count($x_audit_user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_audit_user when calling accountNumApiItemsIdPut'
            );
        }

        $resourcePath = '/{accountNum}/api/Items/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_audit_user !== null) {
            $headerParams['X-AuditUser'] = ObjectSerializer::toHeaderValue($x_audit_user);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($account_num !== null) {
            $resourcePath = str_replace(
                '{' . 'accountNum' . '}',
                ObjectSerializer::toPathValue($account_num),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation accountNumApiItemsIdSetExternalIdPut
     *
     * Sets the ExternalId of the specified item.
     *
     * @param  string $id The ID of the item whose ExternalId to set. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function accountNumApiItemsIdSetExternalIdPut($id, $account_num, $x_audit_user)
    {
        $this->accountNumApiItemsIdSetExternalIdPutWithHttpInfo($id, $account_num, $x_audit_user);
    }

    /**
     * Operation accountNumApiItemsIdSetExternalIdPutWithHttpInfo
     *
     * Sets the ExternalId of the specified item.
     *
     * @param  string $id The ID of the item whose ExternalId to set. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function accountNumApiItemsIdSetExternalIdPutWithHttpInfo($id, $account_num, $x_audit_user)
    {
        $returnType = '';
        $request = $this->accountNumApiItemsIdSetExternalIdPutRequest($id, $account_num, $x_audit_user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FastBoundWebModelsApiV1ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation accountNumApiItemsIdSetExternalIdPutAsync
     *
     * Sets the ExternalId of the specified item.
     *
     * @param  string $id The ID of the item whose ExternalId to set. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsIdSetExternalIdPutAsync($id, $account_num, $x_audit_user)
    {
        return $this->accountNumApiItemsIdSetExternalIdPutAsyncWithHttpInfo($id, $account_num, $x_audit_user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation accountNumApiItemsIdSetExternalIdPutAsyncWithHttpInfo
     *
     * Sets the ExternalId of the specified item.
     *
     * @param  string $id The ID of the item whose ExternalId to set. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsIdSetExternalIdPutAsyncWithHttpInfo($id, $account_num, $x_audit_user)
    {
        $returnType = '';
        $request = $this->accountNumApiItemsIdSetExternalIdPutRequest($id, $account_num, $x_audit_user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'accountNumApiItemsIdSetExternalIdPut'
     *
     * @param  string $id The ID of the item whose ExternalId to set. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function accountNumApiItemsIdSetExternalIdPutRequest($id, $account_num, $x_audit_user)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling accountNumApiItemsIdSetExternalIdPut'
            );
        }
        // verify the required parameter 'account_num' is set
        if ($account_num === null || (is_array($account_num) && count($account_num) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_num when calling accountNumApiItemsIdSetExternalIdPut'
            );
        }
        // verify the required parameter 'x_audit_user' is set
        if ($x_audit_user === null || (is_array($x_audit_user) && count($x_audit_user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_audit_user when calling accountNumApiItemsIdSetExternalIdPut'
            );
        }

        $resourcePath = '/{accountNum}/api/Items/{id}/SetExternalId';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_audit_user !== null) {
            $headerParams['X-AuditUser'] = ObjectSerializer::toHeaderValue($x_audit_user);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($account_num !== null) {
            $resourcePath = str_replace(
                '{' . 'accountNum' . '}',
                ObjectSerializer::toPathValue($account_num),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation accountNumApiItemsIdUndisposePut
     *
     * Undisposes the specified item.
     *
     * @param  string $id The ID of the item to undispose. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function accountNumApiItemsIdUndisposePut($id, $account_num, $x_audit_user)
    {
        $this->accountNumApiItemsIdUndisposePutWithHttpInfo($id, $account_num, $x_audit_user);
    }

    /**
     * Operation accountNumApiItemsIdUndisposePutWithHttpInfo
     *
     * Undisposes the specified item.
     *
     * @param  string $id The ID of the item to undispose. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function accountNumApiItemsIdUndisposePutWithHttpInfo($id, $account_num, $x_audit_user)
    {
        $returnType = '';
        $request = $this->accountNumApiItemsIdUndisposePutRequest($id, $account_num, $x_audit_user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FastBoundWebModelsApiV1ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation accountNumApiItemsIdUndisposePutAsync
     *
     * Undisposes the specified item.
     *
     * @param  string $id The ID of the item to undispose. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsIdUndisposePutAsync($id, $account_num, $x_audit_user)
    {
        return $this->accountNumApiItemsIdUndisposePutAsyncWithHttpInfo($id, $account_num, $x_audit_user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation accountNumApiItemsIdUndisposePutAsyncWithHttpInfo
     *
     * Undisposes the specified item.
     *
     * @param  string $id The ID of the item to undispose. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsIdUndisposePutAsyncWithHttpInfo($id, $account_num, $x_audit_user)
    {
        $returnType = '';
        $request = $this->accountNumApiItemsIdUndisposePutRequest($id, $account_num, $x_audit_user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'accountNumApiItemsIdUndisposePut'
     *
     * @param  string $id The ID of the item to undispose. (required)
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function accountNumApiItemsIdUndisposePutRequest($id, $account_num, $x_audit_user)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling accountNumApiItemsIdUndisposePut'
            );
        }
        // verify the required parameter 'account_num' is set
        if ($account_num === null || (is_array($account_num) && count($account_num) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_num when calling accountNumApiItemsIdUndisposePut'
            );
        }
        // verify the required parameter 'x_audit_user' is set
        if ($x_audit_user === null || (is_array($x_audit_user) && count($x_audit_user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_audit_user when calling accountNumApiItemsIdUndisposePut'
            );
        }

        $resourcePath = '/{accountNum}/api/Items/{id}/Undispose';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_audit_user !== null) {
            $headerParams['X-AuditUser'] = ObjectSerializer::toHeaderValue($x_audit_user);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($account_num !== null) {
            $resourcePath = str_replace(
                '{' . 'accountNum' . '}',
                ObjectSerializer::toPathValue($account_num),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation accountNumApiItemsSetExternalIdsPut
     *
     * Sets the ExternalId of each of the specified items.
     *
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     * @param  string $id id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function accountNumApiItemsSetExternalIdsPut($account_num, $x_audit_user, $id = null)
    {
        $this->accountNumApiItemsSetExternalIdsPutWithHttpInfo($account_num, $x_audit_user, $id);
    }

    /**
     * Operation accountNumApiItemsSetExternalIdsPutWithHttpInfo
     *
     * Sets the ExternalId of each of the specified items.
     *
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     * @param  string $id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function accountNumApiItemsSetExternalIdsPutWithHttpInfo($account_num, $x_audit_user, $id = null)
    {
        $returnType = '';
        $request = $this->accountNumApiItemsSetExternalIdsPutRequest($account_num, $x_audit_user, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FastBoundWebModelsApiV1ErrorResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation accountNumApiItemsSetExternalIdsPutAsync
     *
     * Sets the ExternalId of each of the specified items.
     *
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     * @param  string $id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsSetExternalIdsPutAsync($account_num, $x_audit_user, $id = null)
    {
        return $this->accountNumApiItemsSetExternalIdsPutAsyncWithHttpInfo($account_num, $x_audit_user, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation accountNumApiItemsSetExternalIdsPutAsyncWithHttpInfo
     *
     * Sets the ExternalId of each of the specified items.
     *
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     * @param  string $id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function accountNumApiItemsSetExternalIdsPutAsyncWithHttpInfo($account_num, $x_audit_user, $id = null)
    {
        $returnType = '';
        $request = $this->accountNumApiItemsSetExternalIdsPutRequest($account_num, $x_audit_user, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'accountNumApiItemsSetExternalIdsPut'
     *
     * @param  string $account_num The assigned account number. (required)
     * @param  string $x_audit_user Email address of a FastBound user who has access to the specified account for audit purposes. (required)
     * @param  string $id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function accountNumApiItemsSetExternalIdsPutRequest($account_num, $x_audit_user, $id = null)
    {
        // verify the required parameter 'account_num' is set
        if ($account_num === null || (is_array($account_num) && count($account_num) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_num when calling accountNumApiItemsSetExternalIdsPut'
            );
        }
        // verify the required parameter 'x_audit_user' is set
        if ($x_audit_user === null || (is_array($x_audit_user) && count($x_audit_user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_audit_user when calling accountNumApiItemsSetExternalIdsPut'
            );
        }

        $resourcePath = '/{accountNum}/api/Items/SetExternalIds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id, 'uuid');
        }
        // header params
        if ($x_audit_user !== null) {
            $headerParams['X-AuditUser'] = ObjectSerializer::toHeaderValue($x_audit_user);
        }

        // path params
        if ($account_num !== null) {
            $resourcePath = str_replace(
                '{' . 'accountNum' . '}',
                ObjectSerializer::toPathValue($account_num),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
